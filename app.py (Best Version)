import os
import threading
import uuid
import tempfile
import shutil
import random
import time
from datetime import datetime
from flask import Flask, request, render_template_string, send_file, redirect, url_for
import asyncio
import edge_tts
import requests
import subprocess
from pydub import AudioSegment
import logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

PEXELS_API_KEY = "qzV2sjHrGTLBFPd9pzWika84j3ehYJ1rnvXaG2DREBQq9uw6iZq6h9aV"
OUTPUT_FOLDER = "outputs"
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

TAGS_PREDEFINIDOS = [
    "banking", "dinero", "judios", "israel", "bank", "scam", "sad people", "city",
    "credit card", "gods", "space galaxy", "office", "finanzas", "mentiras", "desesperacion", "astral", "watching tv",
    "universo", "spiral", "ladron","oficina", "vendedor", "business", "control","people streets", "loan","mortage"
]

VOICE_LIST = [
    "es-ES-ElviraNeural",
    "es-AR-TomasNeural"
]
DEFAULT_VOICE = "es-ES-ElviraNeural"

def clean_old_files(folder, max_age_hours=2):
    now = time.time()
    EXTENSIONS = (".mp4", ".mp3", ".wav", ".m4a", ".webm", ".avi", ".mov", ".flac")
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        if os.path.isfile(file_path) and file_path.lower().endswith(EXTENSIONS):
            file_age = now - os.path.getmtime(file_path)
            if file_age > max_age_hours * 3600:
                try:
                    os.remove(file_path)
                except Exception:
                    pass

clean_old_files(OUTPUT_FOLDER, max_age_hours=2)

def auto_delete_file(path, delay_seconds=7200):
    def delete():
        time.sleep(delay_seconds)
        try:
            if os.path.exists(path):
                os.remove(path)
        except Exception:
            pass
    threading.Thread(target=delete, daemon=True).start()

async def generate_voice(text, voice, output_path):
    try:
        start = time.time()
        communicate = edge_tts.Communicate(text, voice)
        await communicate.save(output_path)
        logging.info(f"‚úÖ Voz generada en {time.time()-start:.2f}s")
        return os.path.exists(output_path)
    except Exception:
        return False

def search_videos(tag, max_results=15):
    start = time.time()
    headers = {"Authorization": PEXELS_API_KEY}
    params = {"query": tag, "per_page": max_results}
    try:
        response = requests.get("https://api.pexels.com/videos/search", headers=headers, params=params, timeout=10)
        data = response.json()
        urls = [video['video_files'][0]['link'] for video in data.get('videos', []) if video.get('video_files')]
        logging.info(f"üîé B√∫squeda de videos '{tag}' en {time.time()-start:.2f}s ({len(urls)} resultados)")
        return urls
    except Exception:
        return []

def download_video(url, dir_path):
    start = time.time()
    try:
        filename = os.path.join(dir_path, f"{datetime.now().timestamp()}.mp4")
        r = requests.get(url, stream=True, timeout=30)
        with open(filename, "wb") as f:
            for chunk in r.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
        if os.path.getsize(filename) > 1000:
            logging.info(f"‚¨áÔ∏è Video descargado en {time.time()-start:.2f}s")
            return filename
        else:
            return None
    except Exception:
        return None

def recode_video(input_path, output_path):
    start = time.time()
    subprocess.run([
        "ffmpeg", "-y", "-i", input_path,
        "-vf", "scale=1280:720,fps=30",
        "-c:v", "libx264", "-preset", "veryfast",
        "-an",
        output_path
    ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    logging.info(f"üéûÔ∏è Video recodificado en {time.time()-start:.2f}s")

def create_sequenced_music(music_files, total_duration, temp_dir):
    start = time.time()
    if not music_files:
        return None
    music_durs = []
    valid_music_files = []
    for mf in music_files:
        if not os.path.exists(mf):
            continue
        result = subprocess.run([
            "ffprobe", "-v", "error", "-show_entries", "format=duration", "-of",
            "default=noprint_wrappers=1:nokey=1", mf
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        try:
            dur = float(result.stdout.strip())
            if dur > 0:
                music_durs.append(dur)
                valid_music_files.append(mf)
        except Exception:
            continue
    if not valid_music_files:
        return None
    cycle_dur = sum(music_durs)
    if cycle_dur == 0:
        return None
    sequenced_list = []
    current_dur = 0
    while current_dur < total_duration:
        for idx, mf in enumerate(valid_music_files):
            sequenced_list.append(mf)
            current_dur += music_durs[idx]
            if current_dur >= total_duration:
                break
        if current_dur >= total_duration:
            break
    list_path = os.path.join(temp_dir, f"music_list_{uuid.uuid4()}.txt")
    with open(list_path, "w") as f:
        for sf in sequenced_list:
            abs_path = os.path.abspath(sf).replace('\\', '\\\\')
            f.write(f"file '{abs_path}'\n")
    concat_music = os.path.join(temp_dir, f"concat_music_{uuid.uuid4()}.mp3")
    subprocess.run([
        "ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", list_path,
        "-c", "copy", concat_music
    ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    if not os.path.exists(concat_music) or os.path.getsize(concat_music) == 0:
        return None
    full_music = os.path.join(temp_dir, f"full_music_{uuid.uuid4()}.mp3")
    subprocess.run([
        "ffmpeg", "-y", "-i", concat_music, "-t", str(total_duration),
        "-c", "copy", full_music
    ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    logging.info(f"üéµ M√∫sica secuenciada en {time.time()-start:.2f}s")
    if not os.path.exists(full_music) or os.path.getsize(full_music) == 0:
        return concat_music
    return full_music

def split_text_safe(text, max_chars=3000):
    parts = []
    while text:
        part = text[:max_chars]
        if len(text) > max_chars:
            cut = max(part.rfind('.'), part.rfind(' '))
            if cut > 0:
                part = part[:cut+1]
        parts.append(part.strip())
        text = text[len(part):].strip()
    return parts

async def generate_all_voices(parts, voices, temp_dir):
    voice_paths = []
    durations = []
    for i, part in enumerate(parts):
        start = time.time()
        current_voice = voices[i % len(voices)]
        voice_path = os.path.join(temp_dir, f"voice_part_{uuid.uuid4()}.mp3")
        communicate = edge_tts.Communicate(part, current_voice)
        await communicate.save(voice_path)
        if not os.path.exists(voice_path):
            raise RuntimeError("Error al generar voz")
        audio = AudioSegment.from_file(voice_path)
        durations.append(audio.duration_seconds)
        voice_paths.append(voice_path)
        logging.info(f"üó£Ô∏è Parte {i+1}/{len(parts)} voz generada en {time.time()-start:.2f}s")
    return voice_paths, durations

def create_video_segment(voice_duration, temp_dir, tags):
    """Crea solo el segmento de VIDEO (sin audio) para una parte del texto"""
    start_total = time.time()
    
    # **MEJORA: Evitar videos repetidos**
    all_video_urls = []
    
    # Mezclar los tags aleatoriamente para variedad
    shuffled_tags = random.sample(tags, min(len(tags), 3)) if len(tags) > 3 else tags
    
    for tag in shuffled_tags:
        urls = search_videos(tag, max_results=15)  # M√°s resultados por tag
        all_video_urls.extend(urls)
    
    # Eliminar duplicados
    all_video_urls = list(set(all_video_urls))
    
    if not all_video_urls:
        return None, "‚ùå No se encontraron clips v√°lidos"
    
    # Mezclar aleatoriamente el orden de URLs
    random.shuffle(all_video_urls)
    
    video_files = []
    total_video = 0
    max_attempts = 30  # M√°s intentos
    attempts = 0
    used_urls = set()  # Evitar repetir los mismos videos
    
    while total_video < voice_duration and attempts < max_attempts and all_video_urls:
        attempts += 1
        
        # Selecci√≥n inteligente: usar y remover de la lista
        video_url = all_video_urls.pop(0)
        
        if video_url in used_urls:
            continue
            
        used_urls.add(video_url)
        video_file = download_video(video_url, temp_dir)
        
        if not video_file:
            continue
            
        recode_path = os.path.join(temp_dir, f"recode_{os.path.basename(video_file)}")
        recode_video(video_file, recode_path)
        
        try:
            result = subprocess.run([
                "ffprobe", "-v", "error", "-show_entries", "format=duration", "-of",
                "default=noprint_wrappers=1:nokey=1", recode_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            vid_duration = float(result.stdout.strip())
        except Exception:
            continue
            
        if total_video + vid_duration < voice_duration:
            video_files.append(recode_path)
            total_video += vid_duration
        else:
            falta = voice_duration - total_video
            recortado = os.path.join(temp_dir, f"recorte_{os.path.basename(recode_path)}")
            subprocess.run([
                "ffmpeg", "-y", "-i", recode_path, "-t", str(falta),
                "-c", "copy", recortado
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            video_files.append(recortado)
            break
            
    if not video_files:
        return None, "‚ùå No se pudieron descargar videos"
        
    list_path = os.path.join(temp_dir, f"list_{uuid.uuid4()}.txt")
    with open(list_path, "w") as f:
        for vf in video_files:
            abs_path = os.path.abspath(vf).replace('\\', '\\\\')
            f.write(f"file '{abs_path}'\n")
            
    segment_path = os.path.join(temp_dir, f"segment_{uuid.uuid4()}.mp4")
    subprocess.run([
        "ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", list_path,
        "-c", "copy", segment_path
    ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    if not os.path.exists(segment_path):
        return None, "‚ùå Fallo en creaci√≥n de segmento de video"
        
    logging.info(f"üé¨ Segmento de video creado en {time.time()-start_total:.2f}s")
    return segment_path, None

def create_video_ffmpeg(text, voice, music_files=None):
    start_total = time.time()
    if music_files is None:
        music_files = []
    temp_dir = tempfile.mkdtemp()
    try:
        parts = split_text_safe(text, max_chars=3000)
        if not parts:
            return None, "‚ùå No se proporcion√≥ texto v√°lido"
        
        # 1. GENERAR TODAS LAS VOCES
        voice_paths, durations = asyncio.run(
            generate_all_voices(parts, ["es-ES-ElviraNeural", "es-AR-TomasNeural"], temp_dir)
        )
        total_duration = sum(durations)
        
        # 2. CREAR M√öSICA DE FONDO CONTINUA
        full_music = None
        if music_files:
            existing_music = [mf for mf in music_files if os.path.exists(mf)]
            if existing_music:
                full_music = create_sequenced_music(existing_music, total_duration, temp_dir)
        
        # 3. CONCATENAR TODAS LAS VOCES EN UN SOLO AUDIO
        voices_concat = os.path.join(temp_dir, f"voices_concat_{uuid.uuid4()}.mp3")
        voices_list_path = os.path.join(temp_dir, f"voices_list_{uuid.uuid4()}.txt")
        with open(voices_list_path, "w") as f:
            for vp in voice_paths:
                abs_path = os.path.abspath(vp).replace('\\', '\\\\')
                f.write(f"file '{abs_path}'\n")
        
        subprocess.run([
            "ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", voices_list_path,
            "-c", "copy", voices_concat
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # 4. CREAR SEGMENTOS DE VIDEO (SIN AUDIO)
        video_segments = []
        for i, duration in enumerate(durations):
            tags = TAGS_PREDEFINIDOS[i::len(parts)]
            if not tags:
                tags = TAGS_PREDEFINIDOS[:5]
            
            video_path, error = create_video_segment(duration, temp_dir, tags)
            if not video_path:
                shutil.rmtree(temp_dir, ignore_errors=True)
                return None, error
            video_segments.append(video_path)
        
        # 5. CONCATENAR TODOS LOS SEGMENTOS DE VIDEO
        video_list_path = os.path.join(temp_dir, f"video_list_{uuid.uuid4()}.txt")
        with open(video_list_path, "w") as f:
            for vs in video_segments:
                abs_path = os.path.abspath(vs).replace('\\', '\\\\')
                f.write(f"file '{abs_path}'\n")
        
        video_concat = os.path.join(temp_dir, f"video_concat_{uuid.uuid4()}.mp4")
        subprocess.run([
            "ffmpeg", "-y", "-f", "concat", "-safe", "0", "-i", video_list_path,
            "-c", "copy", video_concat
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # 6. MEZCLAR AUDIO FINAL (VOCES + M√öSICA) - CONTINUO SIN CORTES
        final_audio = os.path.join(temp_dir, f"final_audio_{uuid.uuid4()}.mp3")
        
        if full_music and os.path.exists(full_music):
            # Mezclar voces con m√∫sica de fondo
            subprocess.run([
                "ffmpeg", "-y", "-i", voices_concat, "-i", full_music,
                "-filter_complex",
                "[0:a]volume=3.5[voice];[1:a]volume=0.13[music];[voice][music]amix=inputs=2:duration=first[aout]",
                "-map", "[aout]",
                "-c:a", "libmp3lame", "-b:a", "320k", final_audio
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            # Solo voces
            shutil.copy(voices_concat, final_audio)
        
        # 7. COMBINAR VIDEO CON AUDIO (SIN FADE OUT TODAV√çA)
        video_pre_final = os.path.join(temp_dir, f"video_pre_final_{uuid.uuid4()}.mp4")
        subprocess.run([
            "ffmpeg", "-y", "-i", video_concat, "-i", final_audio,
            "-c:v", "copy", "-c:a", "aac", "-b:a", "320k",
            "-shortest", video_pre_final
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # 8. APLICAR FADE OUT SOLO AL FINAL (√öLTIMOS 3 SEGUNDOS)
        final_path = os.path.join(OUTPUT_FOLDER, f"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4")
        
        # Obtener duraci√≥n real del video
        result = subprocess.run([
            "ffprobe", "-v", "error", "-show_entries", "format=duration", "-of",
            "default=noprint_wrappers=1:nokey=1", video_pre_final
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        try:
            video_duration = float(result.stdout.strip())
            fade_start = max(0, video_duration - 3)  # Fade out √∫ltimos 3 segundos
        except:
            fade_start = max(0, total_duration - 3)  # Fallback
        
        # Aplicar fade out a audio y video
        subprocess.run([
            "ffmpeg", "-y", "-i", video_pre_final,
            "-af", f"afade=t=out:st={fade_start}:d=3",
            "-vf", f"fade=t=out:st={fade_start}:d=3",
            "-c:v", "libx264", "-c:a", "aac", "-b:a", "320k",
            final_path
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        if not os.path.exists(final_path):
            shutil.rmtree(temp_dir, ignore_errors=True)
            return None, "‚ùå Fallo al crear el video final"
        
        auto_delete_file(final_path, delay_seconds=7200)
        shutil.rmtree(temp_dir, ignore_errors=True)
        logging.info(f"üèÅ Video final creado en {time.time()-start_total:.2f}s")
        return final_path, None
    except Exception as e:
        shutil.rmtree(temp_dir, ignore_errors=True)
        return None, f"‚ùå Error inesperado: {e}"

app = Flask(__name__)
jobs = {}

def background_video_job(job_id, text, voice, music_files):
    video_path, error = create_video_ffmpeg(text, voice, music_files)
    if video_path:
        jobs[job_id]['status'] = 'done'
        jobs[job_id]['file'] = video_path
    else:
        jobs[job_id]['status'] = 'error'
        jobs[job_id]['error'] = error

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        text = request.form.get("text")
        voice = request.form.get("voice", DEFAULT_VOICE)
        music1 = request.files.get("music1")
        music2 = request.files.get("music2")
        music3 = request.files.get("music3")
        if not text or not text.strip():
            return "Error: Se requiere texto", 400
        job_id = str(uuid.uuid4())
        music_files = []
        for i, m in enumerate([music1, music2, music3], start=1):
            if m and m.filename:
                temp_music_path = os.path.join(OUTPUT_FOLDER, f"music_{job_id}_{i}.mp3")
                m.save(temp_music_path)
                music_files.append(temp_music_path)
        jobs[job_id] = {"status": "processing"}
        thread = threading.Thread(target=background_video_job, args=(job_id, text, voice, music_files))
        thread.start()
        return redirect(url_for("status", job_id=job_id))
    voices_options = "".join([f"<option value='{v}'>{v}</option>" for v in VOICE_LIST])
    return render_template_string('''
        <h1>Generador de Videos</h1>
        <form method="post" enctype="multipart/form-data">
            <textarea name="text" rows="10" cols="60" placeholder="Ingrese el texto aqu√≠"></textarea><br>
            <label for="voice">Selecciona voz:</label>
            <select name="voice">{{ voices_options|safe }}</select><br><br>
            <label for="music1">M√∫sica 1:</label><input type="file" name="music1"><br>
            <label for="music2">M√∫sica 2:</label><input type="file" name="music2"><br>
            <label for="music3">M√∫sica 3:</label><input type="file" name="music3"><br><br>
            <button type="submit">Generar Video</button>
        </form>
    ''', voices_options=voices_options)

@app.route("/status/<job_id>")
def status(job_id):
    job = jobs.get(job_id)
    if not job:
        return "Trabajo no encontrado", 404
    if job['status'] == 'processing':
        return '''
        <html>
        <head><meta http-equiv="refresh" content="5"></head>
        <body>
            <h2>üîÑ Procesando video...</h2>
            <p>Trabajo ID: {}</p>
            <p>Esta p√°gina se actualizar√° autom√°ticamente cada 5 segundos.</p>
        </body>
        </html>
        '''.format(job_id)
    elif job['status'] == 'done':
        filename = os.path.basename(job['file'])
        return '''
        <html>
        <body>
            <h2>‚úÖ ¬°Video listo!</h2>
            <p><strong>Archivo:</strong> {}</p>
            <p><strong>Trabajo ID:</strong> {}</p>
            <br>
            <a href="/download/{}" style="font-size: 24px; color: green; text-decoration: none; font-weight: bold;">
            üé¨ DESCARGAR VIDEO AQU√ç üé¨
            </a>
            <br><br>
            <a href="/">‚¨ÖÔ∏è Generar otro video</a>
        </body>
        </html>
        '''.format(filename, job_id, job_id)
    else:
        return '''
        <html>
        <body>
            <h2>‚ùå Error</h2>
            <p><strong>Trabajo ID:</strong> {}</p>
            <p><strong>Error:</strong> {}</p>
            <br>
            <a href="/">‚¨ÖÔ∏è Volver a intentar</a>
        </body>
        </html>
        '''.format(job_id, job.get('error', 'Desconocido'))

@app.route("/download/<job_id>")
def download(job_id):
    job = jobs.get(job_id)
    if not job or not job.get('file'):
        return "Archivo no encontrado", 404
    
    file_path = job['file']
    
    # **CORRECCI√ìN: Verificar que el archivo existe en OUTPUT_FOLDER**
    if not os.path.exists(file_path):
        # Buscar por nombre en OUTPUT_FOLDER
        filename = os.path.basename(file_path)
        new_path = os.path.join(OUTPUT_FOLDER, filename)
        if os.path.exists(new_path):
            file_path = new_path
        else:
            return f"Archivo no encontrado: {filename}", 404
    
    # **CORRECCI√ìN: Usar send_file correctamente**
    try:
        return send_file(file_path, as_attachment=True)
    except Exception as e:
        return f"Error al enviar archivo: {str(e)}", 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
